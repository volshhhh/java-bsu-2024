# Dependency Injection framework

В данной задаче вам предлагается разработать фреймворк для [внедрения зависимостей](https://ru.wikipedia.org/wiki/Внедрение_зависимости).

Чаще всего используются два вида внедрения зависимостей: через конструктор и через сеттер. Однако, в угоду упрощения
реализации, мы займемся реализацией третьего вида - внедрение через поля класса (field injection).

## Архитектура приложения

### Bean
Во-первых, классы, внедрение зависимости для которых пользователь хочет перенести на наш фреймворк, будем называть
`Bean` (бин). В том числе бинами являются внедренные в объект зависимости.

Для объявления класса бином используется аннотация `@Bean`, которая имеет два параметра - **имя бина** (уникальный
в рамках проекта идентификатор) и его тип (`BeanScope`: `Singleton` или `Prototype`).

Бины типа `Singleton` создаются при запуске приложения и должны существовать всегда в единственном экземпляре.

Бины типа `Prototype` не создаются при запуске, а инстанциируются каждый раз по запросу пользователя.

### Inject
При объявлении бина некоторые его внедрение зависимостей в некоторые поля класса можно переложить на фреймворк.
Для этого используется аннотация `@Inject`, которая указывается над полем класса. Такое поле не нужно инициализировать,
конкретное значение будет подставлено фреймворком автоматически.

Выбор подходящего бина из всех зарегистрированных осуществляется по типу поля класса.

### ApplicationContext
Основным элементом фреймворка внедрения зависимостей является так называемый `IoC container`. Он ответственен за сбор
объявлений бинов (bean definition), создание объектов (самих бинов) по их описанию, а также внедрение необходимых
зависимостей в бины.

При создании контекста никакие объекты не создаются, мы лишь сохраняем описания бинов для дальнейшего создания объектов
по ним.

Основная работа происходит при вызове метода `start()` у контекста:
1. Создается единственный экземпляр каждого бина типа `Singleton`.
2. Для всех бинов типа `Singleton` выполняется внедрение зависимостей.
3. Если для бина не удалось подобрать подходящую зависимость, запуск контекста бросает исключение.
4. Контекст готов к использованию.

После запуска контекста можно вызывать у него методы для получения бинов или проверки их наличия:
* `containsBean(String name)`
* `getBean(String name)`
* `getBean(Class<T> clazz)`

Вызов `getBean` для `Singleton` бина каждый раз возвращает один и тот же объект.

Вызов `getBean` для `Prototype` бина каждый раз возвращает новый объект, создавая его из определения бина. Дополнительно
отмечу, что для прототипов в момент создания должны внедряться необходимые зависимости.

Про `IoC container`, реализованный в `Spring Framework`, [можно почитать в документации
спринга](https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html).

#### AbstractApplicationContext
У интерфейса `ApplicationContext` есть абстрактная реализация, которая на данный момент содержит только енам
`ContextStatus`, который объявлен `protected`, чтобы его можно было использовать только для хранения внутреннего
состояния контекста.

В данный класс стоит выносить поля/методы, общие для всех реализаций контекстов.

## Пример работы фреймворка

В проекте уже написан базовый пример работы фреймворка, который использует частично реализованный класс
`HardCodedSingletonApplicationContext`. Внедрение зависимостей тут отсутствует, но показан общий принцип использования
контекста приложения (см. `Main.java`).

Подробнее пример можно посмотреть в пакете `by.bsu.dependency.example`, содержимое представлено ниже:

```java
// file FirstBean.java
@Bean(name = "firstBean")
public class FirstBean {

    void printSomething() {
        System.out.println("Hello, I'm first bean");
    }

    void doSomething() {
        System.out.println("First bean is working on a project...");
    }
}

// file OtherBean.java
@Bean(name = "otherBean")
public class OtherBean {

    @Inject
    private FirstBean firstBean;

    void doSomething() {
        System.out.println("Hi, I'm other bean");
    }

    void doSomethingWithFirst() {
        System.out.println("Trying to shake first bean...");
        firstBean.doSomething();
    }
}

// file Main.java
public class Main {

    public static void main(String[] args) {
        ApplicationContext applicationContext = new HardCodedSingletonApplicationContext(
                FirstBean.class, OtherBean.class
        );
        applicationContext.start();

        FirstBean firstBean = (FirstBean) applicationContext.getBean("firstBean");
        OtherBean otherBean = (OtherBean) applicationContext.getBean("otherBean");

        firstBean.doSomething();
        otherBean.doSomething();

        // Метод падает, так как в классе HardCodedSingletonApplicationContext не реализовано внедрение зависимостей
        // otherBean.doSomethingWithFirst();
    }
}
```

## Этапы реализации

### 1. Доработка `HardCodedSingletonApplicationContext`

Идея класса частично описана в javadoc-е к конструктору. Данная реализация содержит минимальный набор реализованных
функций для работы контекста, **не занимается внедрением зависимостей** и создает только бины с типом `Singleton`.

Более того, к этой реализации написаны тесты, находящиеся в классе `HardCodedSingletonApplicationContextTest`. Сейчас
не все тесты зеленые, поэтому вам предстоит доработать реализацию контекста, чтобы **все тесты выполнялись успешно**.

Также обратите внимание на javadoc-и интерфейса `ApplicationContext`, где прописаны более точные контракты, в том числе
исключения, бросаемые методами. Классов соответствующих исключений не существует, их нужно создать самому.

### 2. Доработка тестов в `HardCodedSingletonApplicationContextTest`

После создания исключений доработайте тесты с `assertThrows`, заменив `RuntimeException` на соответствующий тип
(указан в комментарии с TODO).

Все имеющиеся тесты **должны быть зелеными**.

### 3.1. Реализация `SimpleApplicationContext`

Интерфейс конструктора данной реализации совпадает с `HardCoded` версией, но реализация должна дополнительно:
* **Уметь работать с бинами без аннотации `@Bean`**. Если в конструктор передали класс, на котором нет данной аннотации,
  имя бина выбирается по названию класса, изменяя регистр первой буквы. Например, для класса `OtherBean` должно быть
  выбрано имя `"otherBean"`. Скоуп бина без аннотации берется из дефолта, т.е. равным `Singleton`.
* **Внедрять зависимости**. Для этого при запуске контекста после создания объектов `Singleton` бинов стоит пройтись
  по ним еще раз, проверить все поля на наличие аннотации `@Inject` и вставить туда подходящий по типу бин.
* Запоминать тип бина (`Singleton` или `Prototype`), корректно отвечать на запросы в методах `isPrototype` и
  `isSingleton`.
* При вызове `getBean` проверять тип бина, для `Prototype` бинов тут же создавать их инстанс и внедрять зависимости
  в поля, помеченные `@Inject`. Для `Singleton` бинов все остается без изменений, возвращается ранее созданный объект.

### 3.2. Написание тестов в `SimpleApplicationContextTest`

Напишите юнит-тесты, проверяющие вашу реализацию `SimpleApplicationContext`. Чем больше будет покрытие вашего кода, тем
лучше. Главное, чтобы все ваши **тесты были зелеными**!

Очень важно проверить корректность внедрения зависимости в бины.


### ★ 4.1. Реализация `AutoScanApplicationContext`

Общий принцип работы данного контекста совпадает с предыдущим, но есть одна особенность в конструкторе.

Если в предыдущих контекстах список бинов явно передавался в конструктор контекста, то `AutoScan` контекст должен
сделать это сам, обойдя все классы в указанном пакете и выбрав только помеченные аннотацией `@Bean`.

Почитать подробнее про обход пакета средствами джавы можно
[по ссылке](https://www.baeldung.com/java-find-all-classes-in-package). Советую воспользоваться [вариантом с библиотекой
`Reflections`](https://www.baeldung.com/java-find-all-classes-in-package#2-reflections-library), сама библиотека уже
подключена к проекту в качестве зависимости через `build.gradle`.

### ★ 4.2. Написание тестов в `AutoScanApplicationContextTest`

Напишите юнит-тесты, проверив как минимум сканирование пакетов. Убедитесь, что бины создаются для классов, помеченных
аннотацией `@Bean`, и только для них.

### 5. Пример использования

Оформите пример использования вашего фреймворка, желательно сделать это в отдельном пакете. Пример должен содержать
создание как `Singleton`, так и `Prototype` бинов **с зависимостями**, а также вызов их методов.

### ★ 6. PostConstruct

Реализованный фреймворк имеет одну особенность: все бины должны иметь пустой конструктор. Более того, для бина нет
никакой возможности понять, когда в него добавили все необходимые зависимости...

При этом часто хочется перед работой с бинами выполнить для них "конструкторы" (скорее, `init`-методы), инициализирующие
его состояние, используя подложенные фреймворком зависимости.

Давайте добавим для этого аннотацию `@PostConstruct`, которая будет помечать `init`-методы. Более формально, метод бина,
отмеченный аннотацией `@PostConstruct`, должен быть вызван фреймворком **после внедрения зависимостей, но до завершения
метода `start()`** контекста (или, в случае `Prototype` бинов, **до завершения метода `getBean`**).

Также добавьте пример использования такой аннотации. Убедитесь в том, что внутри метода все зависимости инициализированы
и готовы к использованию.
